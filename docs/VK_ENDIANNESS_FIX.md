# VK Endianness Fix: RISC Zero Groth16 on NEAR

**Date**: 2025-11-28
**Status**: ✅ ROOT CAUSE IDENTIFIED - Implementation in progress
**Issue**: Groth16 proof verification failing on NEAR despite working on Ethereum

---

## Root Cause Analysis

### Problem Statement

RISC Zero Groth16 proofs generated by proof-server verify successfully on Ethereum (238,499 gas) but fail on NEAR with pairing check returning false.

### Investigation Findings

Through systematic byte-by-byte comparison between Ethereum (✓ working) and NEAR (❌ failing), we identified an **endianness mismatch** between verification key constants and proof points.

#### Ethereum (Working) ✓
- **Proof points**: BIG-ENDIAN (native RISC Zero seal format, EIP-197 compatible)
- **VK constants**: BIG-ENDIAN (native Solidity uint256 representation)
- **Public inputs**: Created by `splitDigest()` which reverses then splits
- **Result**: Pairing check passes (238,499 gas)

#### NEAR (Current, Failing) ❌
- **Proof points**: BIG-ENDIAN (using seal as-is, no reversal)
- **VK constants**: LITTLE-ENDIAN (manually reversed from Ethereum values)
- **Public inputs**: Created by `split_digest()` which reverses then splits
- **Result**: Pairing check returns false

### Evidence

#### 1. Proof Point Validation

Testing proof point A.y from seal (contracts/zk-verifier/src/lib.rs):

```python
# Seal bytes (from RISC Zero): 02de8f0e36425ea3fb231f2c6bf290341b894cf1fa160275972e97ca814b24cd

# Interpreted as LITTLE-ENDIAN:
a_y_le = 92788261584046036391061899678135744263210240944860470102111379079503578914306
p       = 21888242871839275222246405745257275088696311157297823662689037894645226208583
a_y_le >= p: TRUE ❌ INVALID!

# Interpreted as BIG-ENDIAN:
a_y_be = 1297853078428345145444197944982206001999381165506900016513945639168764486861
a_y_be < p: TRUE ✅ VALID!
```

**Conclusion**: Proof points are BIG-ENDIAN (same as Ethereum)

#### 2. VK Constant Verification

Comparing Ethereum vs NEAR IC0.x:

```python
# Ethereum IC0.x (BIG-ENDIAN):
0x12ac9a25dcd5e1a832a9061a082c15dd1d61aa9c4d553505739d0f5d65dc3be4

# NEAR IC0.x (stored LITTLE-ENDIAN):
e43bdc655d0f9d730535554d9caa611ddd152c081a06a932a8e1d5dc259aac12

# When reversed back to BE:
12ac9a25dcd5e1a832a9061a082c15dd1d61aa9c4d553505739d0f5d65dc3be4 ✅ MATCH!
```

**Conclusion**: VK constants were pre-reversed to LE (incorrect for NEAR)

#### 3. splitDigest Behavior

From RiscZeroGroth16Verifier.sol:139-142:

```solidity
function splitDigest(bytes32 digest) internal pure returns (bytes16, bytes16) {
    uint256 reversed = reverseByteOrderUint256(uint256(digest));
    return (bytes16(uint128(reversed)), bytes16(uint128(reversed >> 128)));
}
```

Both Ethereum and NEAR reverse the digest before splitting. The resulting uint128 values are compatible with the BE proof/VK format used in Ethereum.

### The Core Issue

NEAR's alt_bn128 precompiles (pairing check) require **all inputs to be in the same endianness**:

- **Current (failing)**: Proof (BE) + VK (LE) + Public inputs (from split) = **ENDIANNESS MISMATCH**
- **Ethereum (working)**: Proof (BE) + VK (BE) + Public inputs (from split) = **CONSISTENT** ✓

---

## Solution

### Strategy

**Use BIG-ENDIAN for everything** to match Ethereum's working approach:

1. **Proof points**: Keep as-is (already BE from RISC Zero seal) ✓
2. **VK constants**: **REVERSE back to BIG-ENDIAN** (undo the pre-reversal)
3. **Public inputs**: Keep current `split_digest` logic ✓

### Implementation

#### Step 1: Reverse VK Constants to Big-Endian

**File**: `contracts/zk-verifier/src/lib.rs` (lines 887-923)

**Constants to update** (38 total):
- `ALPHA_G1_X`, `ALPHA_G1_Y` (2)
- `BETA_G2_X_C0`, `BETA_G2_X_C1`, `BETA_G2_Y_C0`, `BETA_G2_Y_C1` (4)
- `GAMMA_G2_X_C0`, `GAMMA_G2_X_C1`, `GAMMA_G2_Y_C0`, `GAMMA_G2_Y_C1` (4)
- `DELTA_G2_X_C0`, `DELTA_G2_X_C1`, `DELTA_G2_Y_C0`, `DELTA_G2_Y_C1` (4)
- `IC0_X` through `IC5_X`, `IC0_Y` through `IC5_Y` (24)

**Transformation** (example):

```rust
// BEFORE (little-endian, reversed from Ethereum):
const ALPHA_G1_X: [u8; 32] = hex_literal::hex!(
    "e2f26dbea299f5223b646cb1fb33eadb059d9407559d7441dfd902e3a79a4d2d"
);

// AFTER (big-endian, same as Ethereum):
const ALPHA_G1_X: [u8; 32] = hex_literal::hex!(
    "2d4d9aa7e302d9df41749d5507949d05dbea33fbb16c643b22f599a2be6df2e2"
);
```

#### Step 2: Update Documentation

**File**: `contracts/zk-verifier/src/lib.rs`

Update comments (lines 707-719, 883-931):

```rust
/// RISC Zero Seal Format (from ProverOpts::groth16()):
/// - All field elements are BIG-ENDIAN (uint256 format, EIP-197 compatible)
/// - NEAR's alt_bn128 precompiles use BIG-ENDIAN (same as Ethereum)
/// - VK constants are BIG-ENDIAN (same as Ethereum Groth16Verifier.sol)
/// - No byte reversal needed for proof points or VK constants
```

Remove outdated comments about:
- "NEAR expects LITTLE-ENDIAN"
- "VK constants stored in LE format"
- "Empirical testing" notes

---

## Testing Plan

### Phase 1: Integration Test
```bash
# Clean rebuild
rm -rf target/near/zk_verifier target/wasm32-unknown-unknown/release/zk_verifier.wasm
cargo build -p zk-verifier --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/zk_verifier.wasm target/near/zk_verifier.wasm

# Run test
cargo test --test integration_test test_real_proof_verification
```

**Expected outcome**:
- ✅ No BigUint errors
- ✅ Linear combination completes
- ✅ Pairing check returns TRUE (this is the fix!)
- ✅ Test passes

### Phase 2: Full Test Suite
```bash
cargo test --test integration_test
```

### Phase 3: Testnet Deployment
- Deploy updated verifier to NEAR testnet
- Submit proof from proof-server
- Verify on-chain verification succeeds

---

## Risk Assessment

### Low Risk ✓

**Why**:
- Matching Ethereum's proven working approach exactly
- Can validate byte-for-byte with Ethereum
- Easily reversible if needed

**Mitigation**:
- Backup current VK constants
- Test on sandbox before testnet
- Document changes thoroughly

---

## Expected Outcome

After implementing this fix:

1. **Perfect parity with Ethereum**:
   - Same proof format (BE)
   - Same VK format (BE)
   - Same public input derivation
   - Same pairing equation

2. **Performance**: ~238k gas (similar to Ethereum)

3. **Compatibility**: Proofs work on both Ethereum and NEAR without modification

---

## References

- Investigation: `docs/RISC0_GROTH16_INVESTIGATION.md`
- Ethereum verifier: `/private/tmp/risc0-ethereum/contracts/src/groth16/RiscZeroGroth16Verifier.sol`
- NEAR verifier: `contracts/zk-verifier/src/lib.rs`
- EIP-197: https://eips.ethereum.org/EIPS/eip-197
