# RISC Zero Groth16 Proof Verification Investigation

**Date**: 2025-11-28
**Status**: ‚úÖ RESOLVED
**RISC Zero Version**: v3.0.3/v3.0.4

## Problem Statement

RISC Zero Groth16 proofs generated by the proof-server were failing verification on Ethereum (and would fail on NEAR) with early revert and minimal gas usage (1620-8175 gas), indicating the verification was failing before reaching the pairing check.

## Root Cause

The proof-server was using a **manual STARK‚ÜíGroth16 conversion approach** that produced incorrectly formatted seals:

```rust
// ‚ùå INCORRECT APPROACH (before)
let prove_info = prover.prove_with_ctx(
    env,
    &VerifierContext::default(),
    &elf,
    &ProverOpts::succinct(),  // Generate STARK first
)?;

let succinct_receipt = receipt.inner.succinct()?;
let identity_receipt = risc0_zkvm::recursion::identity_p254(succinct_receipt)?;
let seal_bytes = identity_receipt.get_seal_bytes();
let groth16_seal = risc0_groth16::prove::shrink_wrap(&seal_bytes)?;  // Manual conversion
```

This approach produced seals that didn't match the format expected by `RiscZeroGroth16Verifier.sol`.

## Solution

Switched to RISC Zero's **official high-level Groth16 API** (`ProverOpts::groth16()`):

```rust
// ‚úÖ CORRECT APPROACH (after)
let prove_info = prover.prove_with_ctx(
    env,
    &VerifierContext::default(),
    &elf,
    &ProverOpts::groth16(),  // Direct Groth16 generation
)?;

let receipt = prove_info.receipt;
let groth16_receipt = receipt.inner.groth16()?;

// The seal is already properly formatted
let selector = &groth16_receipt.verifier_parameters.as_bytes()[..4];
let mut encoded_seal = Vec::with_capacity(4 + groth16_receipt.seal.len());
encoded_seal.extend_from_slice(selector);
encoded_seal.extend_from_slice(groth16_receipt.seal.as_ref());

let claim = receipt.claim()?;
let claim_digest = claim.digest();
```

**Key Changes:**
1. Use `ProverOpts::groth16()` instead of `ProverOpts::succinct()` + manual conversion
2. Extract seal from `groth16_receipt.seal.as_ref()` which is already properly formatted (256 bytes)
3. Get claim digest from `receipt.claim().digest()` (original guest execution claim)

## Seal Format

The correct seal format for both Ethereum and NEAR is:

```
Total: 260 bytes
‚îú‚îÄ Selector: 4 bytes (0x73c457ba for RISC Zero v3.0.x)
‚îî‚îÄ Seal: 256 bytes (Groth16 proof points)
   ‚îú‚îÄ A.x: 32 bytes (big-endian uint256)
   ‚îú‚îÄ A.y: 32 bytes
   ‚îú‚îÄ B.x_c0: 32 bytes
   ‚îú‚îÄ B.x_c1: 32 bytes
   ‚îú‚îÄ B.y_c0: 32 bytes
   ‚îú‚îÄ B.y_c1: 32 bytes
   ‚îú‚îÄ C.x: 32 bytes
   ‚îî‚îÄ C.y: 32 bytes
```

**Important Notes:**
- All values are **big-endian** (EIP-197 compatible)
- No additional ABI encoding needed - raw bytes work for Solidity's `abi.decode()`
- Selector varies by RISC Zero version (v3.0.x: `0x73c457ba`, v5.0.x: `0xa7b87ed1`)

## Receipt Format

The complete receipt format serialized for contract storage:

```
Total: image_id (32) + claim_digest (32) + selector+seal (260) + journal (variable)

Bytes 0-31:   image_id (guest program hash)
Bytes 32-63:  claim_digest (SHA-256 of ReceiptClaim)
Bytes 64-67:  selector (verifier version identifier)
Bytes 68-323: seal (Groth16 proof: A, B, C points)
Bytes 324+:   journal (public outputs from guest program)
```

## Verification on Ethereum

Test result with corrected proof format:

```solidity
// ‚úÖ PASSES - 238,499 gas
function testVerifyIncomeProof() public view {
    bytes memory seal = hex"73c457ba2a1b7398...";  // 260 bytes
    bytes32 claimDigest = 0x7eee38b9a5a25fb5...;

    verifier.verifyIntegrity(Receipt({
        seal: seal,
        claimDigest: claimDigest
    }));
}
```

## Investigation Steps Taken

1. **Identified wrong verifier contract** - Was using low-level `Groth16Verifier` instead of `RiscZeroGroth16Verifier`
2. **Verified selector matching** - Confirmed `0x73c457ba` matches between proof and v3.0.x verifier
3. **Checked version alignment** - RISC Zero Rust (v3.0.3/v3.0.4) matches Solidity contracts (v3.0.0)
4. **Analyzed seal structure** - Found manual `shrink_wrap()` approach produced incorrect format
5. **Switched to official API** - `ProverOpts::groth16()` generates correct format
6. **Updated test with new proof** - Verification succeeded immediately

## Files Modified

### Proof Server
**File**: `/Users/norman/Development/NEAR/near-private-payroll/proof-server/src/services/prover.rs`

**Changes:**
- Replaced `ProverOpts::succinct()` + manual conversion with `ProverOpts::groth16()`
- Simplified seal extraction to use `groth16_receipt.seal.as_ref()`
- Updated comments to reflect new approach

### Ethereum Test
**File**: `/Users/norman/Development/NEAR/near-private-payroll/ethereum-test/test/Risc0FullVerificationTest.sol`

**Changes:**
- Updated seal hex data with proof generated by `ProverOpts::groth16()`
- Updated comments to reflect v3.0.4 and new generation method

## Performance

- **Proof generation time**: ~59 seconds (local Docker prover)
- **Verification gas cost**: 238,499 gas (Ethereum)
- No change from previous approach - only correctness fixed

## Compatibility

This format is compatible with:
- ‚úÖ Ethereum `RiscZeroGroth16Verifier` (v3.0.0+)
- ‚úÖ NEAR `alt_bn128` precompiles (EIP-197 compatible)
- ‚úÖ Any blockchain with BN254 pairing support

## Next Steps

1. ‚úÖ Ethereum verification working
2. üîÑ Adapt NEAR verifier contract to use same format
3. üîÑ Test end-to-end on NEAR testnet
4. üîÑ Update SDK to use new proof format

## References

- RISC Zero docs: https://dev.risczero.com/api
- EIP-197 (Precompiled contracts for pairing): https://eips.ethereum.org/EIPS/eip-197
- RISC Zero Ethereum contracts: https://github.com/risc0/risc0-ethereum

## Key Takeaways

1. **Always use official high-level APIs** - Manual proof conversions are error-prone
2. **Version alignment is critical** - Selector mismatches cause immediate revert
3. **Raw seal bytes work** - No manual ABI encoding needed for fixed-size struct arrays
4. **Test with known-good proofs** - RISC Zero's test receipts are valuable references
5. **Claim digest source matters** - Use `receipt.claim()` not `identity_receipt.claim()`
